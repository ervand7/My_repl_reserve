# 1. Создать произвольный список
# 2. Добавить новый элемент типа str в конец списка
# 3. Добавить новый элемент типа int на место с индексом
# 4. Добавить новый элемент типа list в конец списка
# 5. Добавить новый элемент типа tuple на место с индексом
# 6. Получить элемент по индексу
# 7. Удалить элемент
# 8. Найти число повторений элемента списка

# my_list = [1, 2, 3, 4, 5]
# my_list.append('54')
# my_list[4] = 1212
# my_list.append(['qw'])
# my_list[3] = (67, 67, 67)
# my_list.remove(1)
# print(my_list.count(2))



# Получите первый и последний элемент списка
# Решение - Интерактивный режим
# >>> lst = ['Нулевой элемент', 'One', 2, 3, 4, (5, 5, 5)]
# >>> lst[0]
# 'Нулевой элемент'
# >>> lst[-1]
# (5, 5, 5)
# print(my_list[-1])



# a = 100
# b = 199
# a, b = b, a
# print(a)
# print(b)


# lst = [0, 0, 1, 2, 3, 3, 3, 3, 3, 3, 4, 5, 5, 6, 7]
# b = set(lst)
# print(len(b))
# print(len(lst))

# e = {('qew'): 'wer', ('qew1'): 'wer1'}
# e['hsjfdjf'] = 453
# e[('222', '33333')] = ['333', '444']
# e[('суки', 'и',  'пидорасы')] = ['22', 'sd', 'sdsd']
# print(e.values())



# a = [14, 28, 57, 57]
# print(set(a))



# st = {'it', 'is', 'set', 1}

# frozen_st = frozenset({'it', 'is', 'frozen', 'set', 2})

# union_st = st | frozen_st
# # print(union_st)

# union_st1 = st & frozen_st
# print(union_st1)





# Создать функцию calc(a, b, operation). Описание входных параметров:
# 1. Первое число
# 2. Второе число
# 3. Действие над ними:
#    1) + Сложить
#    2) - Вычесть
#    3) * Умножить
#    4) / Разделить
#    5) В остальных случаях функция должна возвращать "Операция не поддерживается"



# def calc(a, b, operation):
#     # Задаем дефолтное значение возвращаемого результата
#     result = 'Операция не поддерживается'

#     if operation == '+':
#         result = a + b
#     elif operation == '-':
#         result = a - b
#     elif operation == '*':
#         result = a * b
#     elif operation == '/':
#         # Проверка деления на ноль
#         if b != 0:
#             result = a / b
#         else:
#             result = 'Деление на 0!'

#     # Возвращаем результат выполнения функции
#     return result


# if __name__ == '__main__':
#     # Проверяем корректные значения
#     print(calc(30, 15, '+'))
#     print(calc(30, 15, '-'))
#     print(calc(30, 15, '*'))
#     print(calc(30, 15, '/'))
#     # Проверяем проверку деления на ноль
#     print(calc(30, 0, '/'))
#     # Проверяем неподдерживаемую операцию
#     print(calc(30, 15, '//'))




# Напишите программу, которая будет выводить нечетные числа из списка и остановится, если встретит число 139


#  Функция, которая проверяет входной параметр на четность
# def even(num):
#     # Возвращаем True, если остаток от деления на 2 равен нулю
#     return num % 2 == 0


# if __name__ == '__main__':
#     lst = [1, 34, 78, 345, 111, 8, 5, 34, 9, 3, 139, 56, 2, 67, 69, 90]

#     # В цикле перебираем элементы вышесозданного списка
#     for item in lst:
#         # Если текущий элемент равен 139, то прерываем цикл
#         if item == 139:
#             break
#         # Выводим элемент, если он не является четным
#         if not even(item):
#             print(item)


# def safe_div(x, y):
#     """Do a safe division :-)
# for fun and profit"""
#     if y != 0:
#         z = x / y
#         print(z)
#         return z
#     else:
#         print("Yippie-kay-yay, motherf___er!")


# Создайте список [ 18, 14, 10, 6, 2 ]  с помощью функции range()
# Решение - IDE
# lst = []

# Пробегаемся циклом for по последовательности, которую формирует функция range()
# Начало диапазона: 18
# Конец диапазона: 1(обратите внимание, что 1 не включается в итоговую последовательность)
# Шаг: -4(обратный шаг - двигаемся в сторону уменьшения значений)
# lst = []
# for item in range(18, 1, -4):
#   lst.append(item)

# print(lst)





# # Условие
# # Дан список lst = [11, 5, 8, 32, 15, 3, 20, 132, 21, 4, 555, 9, 20]. 
# # Необходимо вывести элементы, которые одновременно 1) меньше 30 и 2) делятся на 3 без остатка. Все остальные элементы списка необходимо просуммировать и вывести конечный результат.
# # Решение - IDE
# # Задаем константы для значений, заданных в условии
# MEDIAN = 30
# DIV_NUM = 3

# # Создаем список
# lst = [11, 5, 8, 32, 15, 3, 20, 132, 21, 4, 555, 9, 20]

# # Задаем начальное значение переменной для суммы элементов
# sm = 0

# # Поочередно перебираем элементы списка
# for item in lst:
#     # Проверяем, что
#     # 1) Текущий элемент меньше 30
#     # 2) Остаток от деления текущего элемента на 3 равен 0
#     if (item < MEDIAN) and (item % DIV_NUM == 0):
#         print(item)
#     # Добавляем элемент к сумме, если условие не выполнено
#     else:
#         sm += item

# # Выводим конечную сумму
# print('Sum: ', sm)
# # Вывод в консоль
# # 15
# # 3
# # 21
# # 9
# # Sum:  787





# # Написать функцию month_to_season(), которая принимает 1 аргумент - номер месяца - и возвращает название сезона, к которому относится этот месяц. 
# # Например, передаем 2, на выходе получаем 'Зима'. 

# # Имя функции: month_to_season
# # Параметр: month
# def month_to_season(month_number):

#     # Создание словаря для хранения информации о сезонах
#     # Ключ: кортеж(tuple) из номеров входящих в сезон месяцев
#     # Значение: строка(str)-название сезона
#     season_ranges = {
#         (12, 1, 2): 'Winter',
#         (3, 4, 5): 'Spring',
#         (6, 7, 8): 'Summer',
#         (9, 10, 11): 'Autumn'
#     }
#     # Создание переменной для возвращаемого значения функции
#     season = 'Такого месяца не существует'

#     # Цикл, в котором по очереди перебираются пары ключ-значение(номера месяцев - сезон) из словаря
#     for key, value in season_ranges.items():
#         # Если значение входного параметра(номер месяца) входит в состав ключа(пример ключа - (3, 4, 5))
#         if month_number in key:
#             # То присваиваем возвращаемой переменной season название сезона
#             season = value
#             # Останавливаем цикл
#             break
            
#     # Возвращаем название сезона
#     return season



# # Проверяем работу функции
# print(month_to_season(1))
# print(month_to_season(5))
# print(month_to_season(8))
# print(month_to_season(9))
# print(month_to_season(12))
# print(month_to_season(999))
# print(month_to_season(121212))
# # Вывод в консоль
# # Winter
# # Spring
# # Summer
# # Autumn
# # Winter
# # None

# ||||||||||||||||||||||||||||||||||||||||||||||||||||||


# Дана следующая строка: ‘Сидел барсук в своей норе и ел картошечку пюре’

# 1. Создайте данную строку
# 2. Получите ее длину
# 3. Проведите операцию сложения со строкой ‘.’
# 4. Проверьте, входит ли подстрока ‘ре’ в заданную строку
# 5. Посчитайте количество вхождений подстроки ‘ре’
# 6. Получите предпоследний символ строки
# 7. Получите все символы с нечетными индексами
# 8. Определите, сколько слов в строке

# мой вариант
# str_ = 'Сидел барсук в своей норе и ел картошечку пюре'
# print(len(str_))
# a = str_.split()
# print(len(a))
# print(str_ + ' 22')
# print(str_.count('ре'))
# print(str_[-2])
# print(str_[1::2])

# # 1. Создаем строку
# >>> my_str = 'Сидел барсук в своей норе и ел картошечку пюре'

# # 2. Получаем длину строки с помощью встроенного метода len()
# >>> len(my_str)
# 46

# # 3. Выполняем конкатенацию строк
# >>> my_str + '.'
# 'Сидел барсук в своей норе и ел картошечку пюре.'

# # 4. Определяем вхождение подстроки 'ре'
# >>> 'ре' in my_str
# True

# # 5. Определяем количество вхождений подстроки 'ре'
# >>> my_str.count('ре')
# 2

# # 6. Получаем предпоследний символ строки
# >>> my_str[-2]
# 'р'

# # 7. Получаем элементы с нечетными индексами
# # Для этого выполняем срез, начиная с элемента с индексом 1 по конец строки с шагом 2
# >>> my_str[1::2]
# 'ие асквсойнр  лкроек юе'

# # 8. Определяем количество слов в строке
# # Для этого считаем количество пробелов и прибавляем 1
# >>> my_str.count(' ') + 1
# 9




# Дана строка: ‘пишите код так, как будто сопровождать его будет склонный к насилию психопат, который знает, где вы живете.’

# 1. Начните строку с заглавной буквы, если она находится в нижнем регистре.
# 2. Найдите индекс вхождения подстроки ‘сопровождать’.
# 3. Замените вхождение подстроки ‘сопровождать’ на ‘поддерживать’.
# 4. Разбейте предложение на части по запятым. Соедините части обратно, снова добавив запятые между частями.

# my_str = 'пишите код так, как будто сопровождать его будет склонный к насилию психопат, который знает, где вы живете.'

# # 1. Создаем строку
# >>> my_str = 'пишите код так, как будто сопровождать его будет склонный к насилию психопат, который знает, где вы живете.'

# # 2. Проверяем регистр строки и делаем первую букву заглавной, если регистр нижний
# >>> if my_str.islower(): my_str.capitalize()
# ... 
# 'Пишите код так, как будто сопровождать его будет склонный к насилию психопат, который знает, где вы живете.'

# # 3. Ищем индекс вхождения подстроки 'сопровождать'
# # Вариант 1: Используем метод find() - строковый метод
# >>> my_str.find('сопровождать')
# 26
# # Вариант 2: Используем метод index() - метод для работы с любыми последовательностями
# >>> my_str.index('сопровождать')
# 26

# # 4. Заменяем подстроку 'сопровождать' на 'поддерживать'
# >>> my_str.replace('сопровождать', 'поддерживать')
# 'пишите код так, как будто поддерживать его будет склонный к насилию психопат, который знает, где вы живете.'

# # 5. Разбиваем строку на подстроки по разделителю ',' и сохраняем подстроки в список
# >>> lst = my_str.split(',')
# >>> lst
# ['пишите код так', ' как будто сопровождать его будет склонный к насилию психопат', ' который знает', ' где вы живете.']

# # Соединяем полученные ранее подстроки обратно
# >>> ','.join(lst)
# 'пишите код так, как будто сопровождать его будет склонный к насилию психопат, который знает, где вы живете.'



# # Сложите цифры целого числа.
# num = 12345
# # Вариант решения 1 - пользуемся циклом for
# def sum_for(num):
#     # Инициализируем переменную для суммы
#     s = 0
#     # Преобразуем число в строку
#     # В цикле перебираем символы полученной строки
#     for item in str(num):
#         # Каждый символ переводим в число и добавляем к сумме
#         s += int(item)
#     # Возвращаем конечную сумму
#     return s

# # Вариант решения 2 - используем генераторы списков
# def sum_list(num):
#     # Создаем список с помощью генератора
#     # Конечные элементы списка переводим в числа
#     lst = [int(item) for item in str(num)]
#     # С помощью встроенной функции sum() находим сумму элементов списка
#     return sum(lst)

# # if __name__ == '__main__':
# print(sum_for(num))
# print(sum_list(num))

# Замените заданное количество вхождений подстроки.

# STR = '01101011101011'


# # Тесты
# if __name__ == '__main__':
#     # Заменяем 1 ноль на единицу
#     print(STR.replace('1', '0', 1))
#     # Заменяем 5 нулей на единицы
#     print(STR.replace('1', '0', 5))
#     # Заменяем все единицы на нули(значение по-умолчанию)
#     print(STR.replace('1', '0'))
#     # Заменяем 9 нулей на единицы(все присутствующие единицы)
#     print(STR.replace('1', '0', 6))
#     # Заменяем 10 нулей на единицы(количество единиц больше, чем есть в строке)
#     print(STR.replace('1', '0', 110))








# Список из нескольких строк для тестирования работы функции check_if_palindrome()
TESTS = ['Аргентина манит негра',
         'аргентина манит негра',
         'Манит Аргентина негра']


# # Функция, которая проверяет, является ли переданная строка string палиндромом
# def check_if_palindrome(string):
#     # Для упрощения процесса проверки удаляем пробелы между словами
#     # И переводим строку в нижний регистр
#     prepared_str = string.replace(' ', '').lower()
#     # Используем срез с обратным шагом, чтобы перевернуть строку задом наперед
#     # Если строка равна своей перевернутой копии
#     if prepared_str == prepared_str[::-1]:
#         # Возвращаем логическое True
#         return True
#     else:
#         # Возвращаем логическое False
#         return False


# if __name__ == '__main__':
#     # Прогоняем в цикле все тестовые строки из списка
#     # Для каждой строки вызываем функцию, выполняем проверку и печатаем результат
#     for item in TESTS:
#         print('Строка является палиндромом:', check_if_palindrome(item))






# Дана строка из двух слов. Поменяйте слова местами. 

# def swap_words(string):
#     # Формируем список из слов строки
#     lst = string.split(' ')
#     # Меняем порядок слов на обратный
#     lst.reverse()
#     # Соединяем слова в предложение через пробелы и возвращаем полученное значение
#     return ' '.join(lst)


# if __name__ == '__main__':
#     print(swap_words('идет снег'))
#     print(swap_words('идет снег давно'))


# my_str = 'пишите код так, как будто сопровождать его будет склонный к насилию психопат, который знает, где вы живете.'
# if my_str.islower():
#   print(my_str.capitalize())

# print(my_str.find('сопровождать'))
# print(my_str.index('сопровождать'))

# print(my_str.replace('сопровождать', 'поддерживать'))

# lst = my_str.split(',')
# print(lst)
# lst2 = ','.join(lst)
# print(lst2)

# lst3 = '0'.join(my_str)
# print(lst3)

# my_list2 = ['хуй', 'на хуй', 'не меняй', 'пидорас.']
# print(my_list2)
# my_list2_join = ','.join(my_list2)
# print(my_list2_join)


# # Импортируем стандартный модуль re для работы с регулярными выражениями
# import re

# # Создаем константу для имени файла, которое будет использовать для тестов
# FILENAME = 'folder1/folder2/file.ext'


# # Вариант решения 1 - пользуемся срезами
# def extention_slice(filename):
#     # Находим индекс точки
#     point_pos = filename.find('.')
#     # Возвращаем срез начиная с позиции после точки и до конца имени файла
#     return filename[point_pos + 1:]

# if __name__ == '__main__':
#     print(extention_slice(FILENAME))
#     # print(extention_part(FILENAME))
#     # print(extention_regex(FILENAME))



# NUM = 12345
# # Вариант решения 1 - пользуемся циклом for
# def sum_for(num):
#     # Инициализируем переменную для суммы
#     s = 0
#     # Преобразуем число в строку
#     # В цикле перебираем символы полученной строки
#     for item in str(num):
#         # Каждый символ переводим в число и добавляем к сумме
#         s += int(item)
#     # Возвращаем конечную сумму
#     return s

# def sum_list(num):
#     # Создаем список с помощью генератора
#     # Конечные элементы списка переводим в числа
#     lst = [int(item) for item in str(num)]
#     # С помощью встроенной функции sum() находим сумму элементов списка
#     return sum(lst)



# if __name__ == '__main__':
#       print(sum_for(NUM))
#       print(sum_list(NUM))


# STR = '01101011101011'


# # Тесты
# if __name__ == '__main__':
#     # Заменяем 1 ноль на единицу
#     print(STR.replace('1', '0', 1))
#     # Заменяем 5 нулей на единицы
#     print(STR.replace('1', '0', 5))
#     # Заменяем все нули на единицы(значение по-умолчанию)
#     print(STR.replace('1', '0'))
#     # Заменяем 9 нулей на единицы(все присутствующие единицы)
#     print(STR.replace('1', '0', 9))
#     # Заменяем 10 нулей на единицы(количество единиц больше, чем есть в строке)
#     print(STR.replace('1', '0', 10))


# # Список из нескольких строк для тестирования работы функции check_if_palindrome()
# TESTS = ['Аргентина манит негра',
#          'аргентина манит негра',
#          'Манит Аргентина негра']


# # Функция, которая проверяет, является ли переданная строка string палиндромом
# def check_if_palindrome(string):
#     # Для упрощения процесса проверки удаляем пробелы между словами
#     # И переводим строку в нижний регистр
#     prepared_str = string.replace(' ', '').lower()
#     # Используем срез с обратным шагом, чтобы перевернуть строку задом наперед
#     # Если строка равна своей перевернутой копии
#     if prepared_str == prepared_str[::-1]:
#         # Возвращаем логическое True
#         return True
#     else:
#         # Возвращаем логическое False
#         return False


# if __name__ == '__main__':
#     # Прогоняем в цикле все тестовые строки из списка
#     # Для каждой строки вызываем функцию, выполняем проверку и печатаем результат
#     for item in TESTS:
#         print('Строка является палиндромом:', check_if_palindrome(item))



# def swap_words(string):
#     # Формируем список из слов строки
#     lst = string.split(' ')
#     # Меняем порядок слов на обратный
#     lst.reverse()
#     # Соединяем слова в предложение через пробелы и возвращаем полученное значение
#     return ' '.join(lst)


# if __name__ == '__main__':
#     print(swap_words('идет снег'))
#     print(swap_words('идет снег давно'))

# lst = [1, 2, 3, 14, 33, 1, 1]
# lst.extend('Добавка')
# print(lst)

# lst = [1, 2, 3, 14, 33, 1, 1]
# lst.append('Добавка')
# print(lst)

# text = 'Строка'
# print(list(text))


# text = 'Строка'
# new_list = []
# for item in text:
#     new_list.append(item)
# print(new_list)


# a = [1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89]
# sm = 0

# for element in a:
#   if element < 5:
#     print(element)
#   else:
#     sm += element
#     print(sm)

# print([elem for elem in a if elem < 5])


a = [1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89]

b = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13]

# c = set(a)
# d = set(b)

# e = c ^ d
# print(e)

# result = []
# for elem in a:
#     if elem in b:
#         result.append(elem)
# print(result)

# #ПОКА ЭТОГО НЕ ПРОХОДИЛИ
# import operator
# d = {1: 2, 3: 4, 4: 3, 2: 1, 0: 0}
# result = dict(sorted(d.items(), key=operator.itemgetter(1)))
# print(result)

# result2 = dict(sorted(d.items(), key=operator.itemgetter(1), reverse=True))
# print(result2)


# dict_a = {1:10, 2:20}
# dict_b = {3:30, 4:40}
# dict_c = {5:50, 6:60}

# # print({**dict_a, **dict_b, **dict_c})

# result = {}
# for i in (dict_a, dict_b, dict_c):
#     result.update(i)
# print(result)

# # НАДО ПОДУЧИТЬ!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
# my_dict = {'a':500, 'b':5874, 'c': 560,'d':400, 'e':5875, 'f': 20}
# # мне нужно сортировать значения а потом написать программу, которая выдает именно первые 3 ключа
# result = sorted(my_dict, key=my_dict.get, reverse = True)[:3]
# print(result)


# # Я не понял этого" !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
# print(int('abc', 16))


 # треугольник Паскаля!!!!!!!!!!!!!!!!!!
# def pascal_triangle(n):
#    a = [1]
#    y = [0]
#    for x in range(max(n, 0)):
#       print(a)
#       a = [left + right for left, right in zip(a + y, y + a)]
   
# pascal_triangle(13) 

# def is_palindrome(string):
#     return string == ''.join(reversed(string))

# print(is_palindrome('abba'))

# def is_palindrome(string):
#     return string == string[::-1]

# print(is_palindrome('abba'))

def convert(seconds):
    days = seconds // (24 * 3600)
    seconds %= 24 * 3600
    hours = seconds // 3600
    seconds %= 3600
    minutes = seconds // 60
    seconds %= 60
    print(f'{days}:{hours}:{minutes}:{seconds}')

convert(7777777)
