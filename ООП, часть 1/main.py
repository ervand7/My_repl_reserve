class Track():
    # Мы отдельно артибуты класса Track не прописываем. Пропишем их внутри функции __init__, чтобы они
    # потом автоматичеси вызывались.
    def __init__(self, name="Незаполненное название", duration=0):
        self.name = name
        self.duration = duration

    def show(self):
        return f"{self.name} - {self.duration}"

    # ________________________________________________________________________________________________
    # Внимание! Ниже прописаны 2 функции, наличие которых никак не влияет на конечный результат
    # решения этой задачи. Мы можем и закомментировать их, и ничего не изменится. Мы это все
    # прописываем только потому, что в условии нас просят, и больше не для чего.
    def track_name(self, name):
        self.name = name

    def track_duration(self, duration):
        self.duration = duration
    # ________________________________________________________________________________________________


class Album():
    # Здесь, как и в классе выше, мы атрибуты отдельно не прописываем, а прописываем их внутри __init__
    def __init__(self, name=" ", group=" "):
        self.name = name  # название альбома
        self.group = group  # название группы
        self.tracks = []  # список треков

    # ________________________________________________________________________________________________
    # Далее прописываем 2 идентичные функции: одну для названий и длительностей, вторую
    # для суммы всех длительностей альбома
    def get_tracks(self):
        # для этого используем генератор списков, чтобы все вывести в одну строчку.
        # Используем для удобства возврата значения return. Перед циклом for прописываем i с методом из
        # первой функции .show (в задании так и говорится, использовать .show).
        # То есть мы проходимся по каждому треку, в котором есть self.name и self.duration (см. стр. 4-6)
        # И все эти итерации происходят в списке self.tracks (см. стр. 28), который изначально = [],
        # но далее с помощью фунцкии add_track туда добавляются треки по очереди.
        # Но мы немного забежим вперед!!!
        # Обратите внимание, что после .show мы обязательно обозначаем вызов ()
        return [i.show() for i in self.tracks] # Эта i даст нам все треки

    def get_duration(self):
        # здесь аналогично функции выше мы используем генератор списков. Но на этот раз для вывода суммы
        # длительности альбома. Для этого также используем return и заворачиваем генератор списка в
        # функцию sum. И уже мы итериуемся не как в прошлой функции по ({self.name} + {self.duration})
        # , а только по длительности  i.duration, чтобы потом нам функция sum все сложила.
        # Обратите внимание, что здесь к i мы прикрепляем не как в прошлый раз метод .show, а атрибут
        # duration (см. стр. 4-6).
        # Именно атрибут. Потому что нам нужно, чтобы i каждый раз показывала значение атрибута.
        # А итерируемся мы снова, как и в прошлый раз, соответственно в том же списке self.tracks
        return sum([i.duration for i in self.tracks])

    # ________________________________________________________________________________________________

    # Прописываем последнюю требуемую от нас в задании функцию - функцию на добавление треков.
    # Эта функция нам нужна для того, чтобы в пустой список self.tracks добавлялись новые треки
    def add_track(self, description_of_track):
        self.tracks.append(description_of_track)

# Создаем единый список для всех альбомов, чтобы потом добавлять в него альбомы и проводить итерации
albums = []
# создаем первый по счету альбом. Прописываем туда стразу 2 значения строками. В дальнейшем
# первое значение будет у нас названием альбома, второе - названием группы
album = Album("Первый альбом", "Первый исполнитель")
# подряд добавляем 3 трека по след схеме:
# 1) Пишем название альбома (оно же и эземпляр класса Album)
# 2) Далее используем через точку метод add_track.
# 3) Далее перед названием трека прописываем его класс, откуда он. В нашем случае он из класса Track.
# 4) Далее, внутри обозначенного Track у нас идет отсылка к самому первому методу (см. стр. 4-6),
# то есть прописываем название и длительность трека
album.add_track(Track("Частушка", 1))
album.add_track(Track("Лирика", 4))
album.add_track(Track("Романс", 3))
# после того, как прописали последний трек альбома, добавляем весь альбом в albums
# который по умолчанию у нас = []
albums.append(album)

# По той же схеме все выполняем и для второго альбома
album2 = Album("Другой альбом", "Другой исполнитель")
album2.add_track(Track("Баллада", 2))
album2.add_track(Track("Менуэт", 5))
album2.add_track(Track("Серенада", 5))
albums.append(album2)

# ________________________________________________________________________________________________

# И вот настал заключительный этап всей задачи. Нам нуно проитерироваться в списке albums, в
# который мы уже добавили 2 альбома.
# Отдельно от всех классов, функций и тд создаем цикл.
for i in albums:
    # здесь мы итерируемся в значениях списка с альбомами. А значений у нас 2.
    # Здесь при итерации мы в каждой i отсылаемся к самой первой функции в классе Album (см. стр. 25-28).
    # То есть i.name (название альбома) и i.group - название группы. Именно для этого момента
    # мы и создавали список альбомов albums.
    # И именно для этого момента на стр. 66 и стр. 81 мы прописывали 2 значения, когда
    # создавали экземпляр, а именно:
    # album = Album("Первый альбом", "Первый исполнитель") и
    # album2 = Album("Другой альбом", "Другой исполнитель")
    print(f"Альбом '{i.name}' группы '{i.group}'.")
    # Создаем вложенный цикл, чтобы пройтись подробно по составляющим каждого трека.
    # для того, чтобы каждый трек у нас имел порядковый номер, мы используем функцию enumerate и
    # в конце пишем цифру 1, тем самым обозначая, что отсчет начнется с цифры '1'.
    # Обратите внимание, что после .get_tracks мы обязательно обозначаем вызов ().
    for s in enumerate(i.get_tracks(), 1):
        # здесь расписываем, что:
        # 1) сначала выводится порядковый номер, который у нас появляется благодаря функции enumerate. 
        # 2) потом прописываем '.', она там по смыслу.
        # 3) потом прописываем сам трек, который у нас уже на данном этапе по умолчанию 
        # является ({self.name} - {self.duration}). Это значение пункта 3 появляется благодаря
        # вызову как раз выше прописаной функции .get_tracks() (см. стр. 33-42). 
        print(f"{s[0]}. {s[1]} мин.")
    # И выводим в конце каждого альбома его длительность. Это уже делаем на уровне цикла
    # первого уровня вложенности. Так как и итерируемая i одна и та же. Ну и прописываем
    # специальную функцию .get_duration() (см. стр. 44-53, которую мы и писали для этого момента. 
    # Обратите внимание, что после .get_duration мы обязательно обозначаем вызов ().
    print(f"Общая длительность альбома: {i.get_duration()} минут.\n")
